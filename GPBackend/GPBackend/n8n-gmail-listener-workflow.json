{
  "name": "Job Lander - Gmail Listener (Polling)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Every 5 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "url": "https://evident-melva-nonpunctually.ngrok-free.dev/api/gmail/active-connections",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-Key",
              "value": "aB3dE5fG7hI9jK1lM2nO3pQ4rS5tU6vW7xY8zA9bC0dE="
            }
          ]
        },
        "options": {}
      },
      "id": "get-active-users",
      "name": "Get Active Gmail Users",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [470, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split-users",
      "name": "Split Into Users",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [690, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://evident-melva-nonpunctually.ngrok-free.dev/api/applications?userId={{$json.userId}}&status=Pending&pageSize=100",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-Key",
              "value": "aB3dE5fG7hI9jK1lM2nO3pQ4rS5tU6vW7xY8zA9bC0dE="
            }
          ]
        },
        "options": {}
      },
      "id": "get-pending-applications",
      "name": "Get User Pending Applications",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [910, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://gmail.googleapis.com/gmail/v1/users/me/messages?maxResults=20&labelIds=INBOX&q=after:{{Math.floor(new Date($node[\"Split Into Users\"].json.lastCheckedAt).getTime() / 1000)}}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{$node[\"Split Into Users\"].json.accessToken}}"
            }
          ]
        },
        "options": {}
      },
      "id": "gmail-check-new",
      "name": "Check Gmail for New Emails",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1130, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract messages array and add user context + pending applications\nconst messages = $input.first().json.messages || [];\nconst userId = $node[\"Split Into Users\"].json.userId;\nconst userEmail = $node[\"Split Into Users\"].json.userEmail;\nconst accessToken = $node[\"Split Into Users\"].json.accessToken;\nconst pendingAppsResponse = $node[\"Get User Pending Applications\"].json;\nconst pendingApplications = pendingAppsResponse.items || [];\n\nif (!messages || messages.length === 0) {\n  return [];\n}\n\nreturn messages.map(msg => ({\n  json: {\n    messageId: msg.id,\n    threadId: msg.threadId,\n    userId: userId,\n    userEmail: userEmail,\n    accessToken: accessToken,\n    pendingApplications: pendingApplications\n  }\n}));"
      },
      "id": "extract-messages",
      "name": "Extract Messages & Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1350, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-messages",
              "leftValue": "={{$json.messageId}}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-has-emails",
      "name": "Has New Emails?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1570, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://gmail.googleapis.com/gmail/v1/users/me/messages/{{$json.messageId}}?format=full",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{$json.accessToken}}"
            }
          ]
        },
        "options": {}
      },
      "id": "fetch-full-email",
      "name": "Fetch Full Email Details",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1790, 200]
    },
    {
      "parameters": {
        "jsCode": "// Parse Gmail API response and extract email details\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json;\n  const userId = $node[\"Extract Messages & Context\"].json.userId;\n  const userEmail = $node[\"Extract Messages & Context\"].json.userEmail;\n  const pendingApplications = $node[\"Extract Messages & Context\"].json.pendingApplications;\n  \n  // Extract headers\n  const headers = data.payload?.headers || [];\n  const getHeader = (name) => {\n    const header = headers.find(h => h.name.toLowerCase() === name.toLowerCase());\n    return header ? header.value : '';\n  };\n  \n  const subject = getHeader('Subject');\n  const from = getHeader('From');\n  const date = getHeader('Date');\n  const snippet = data.snippet || '';\n  \n  // Extract body (try to get plain text first, then HTML)\n  let textPlain = '';\n  let textHtml = '';\n  \n  const extractBody = (part) => {\n    if (part.mimeType === 'text/plain' && part.body?.data) {\n      textPlain = Buffer.from(part.body.data, 'base64').toString('utf-8');\n    } else if (part.mimeType === 'text/html' && part.body?.data) {\n      textHtml = Buffer.from(part.body.data, 'base64').toString('utf-8');\n    }\n    \n    if (part.parts) {\n      part.parts.forEach(extractBody);\n    }\n  };\n  \n  if (data.payload) {\n    extractBody(data.payload);\n  }\n  \n  results.push({\n    json: {\n      id: data.id,\n      threadId: data.threadId,\n      subject: subject,\n      from: from,\n      date: date,\n      snippet: snippet,\n      textPlain: textPlain,\n      textHtml: textHtml,\n      internalDate: data.internalDate,\n      userId: userId,\n      userEmail: userEmail,\n      pendingApplications: pendingApplications\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "extract-email-data",
      "name": "Extract Email Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2010, 200]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced email parsing with weighted scoring system\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json;\n  const pendingApplications = data.pendingApplications || [];\n  \n  // Extract email details\n  const subject = (data.subject || '').toLowerCase();\n  const snippet = (data.snippet || '').toLowerCase();\n  const from = data.from || '';\n  const senderEmail = from.toLowerCase();\n  const body = (data.textPlain || data.textHtml || '').toLowerCase();\n  const fullText = `${subject} ${snippet} ${body}`;\n  \n  // Build expected companies database from pending applications\n  const expectedCompanies = pendingApplications.map(app => ({\n    id: app.applicationId,\n    name: (app.companyName || app.company?.name || '').toLowerCase(),\n    jobTitle: (app.jobTitle || '').toLowerCase(),\n    // Extract potential domains from company name\n    domains: extractPotentialDomains(app.companyName || app.company?.name || '')\n  }));\n  \n  // Helper: Extract potential domains from company name\n  function extractPotentialDomains(companyName) {\n    if (!companyName) return [];\n    const clean = companyName.toLowerCase()\n      .replace(/\\s+inc\\.?|\\s+llc\\.?|\\s+ltd\\.?|\\s+corp\\.?/gi, '')\n      .replace(/[^a-z0-9\\s]/g, '')\n      .trim();\n    const words = clean.split(/\\s+/);\n    return [\n      clean.replace(/\\s+/g, ''),  // \"Microsoft Corporation\" -> \"microsoft\"\n      ...words  // [\"microsoft\", \"corporation\"]\n    ];\n  }\n  \n  // Extract sender domain\n  const senderDomainMatch = senderEmail.match(/@([^>\\s]+)/);\n  const senderDomain = senderDomainMatch ? senderDomainMatch[1].toLowerCase() : '';\n  \n  // Known ATS platforms with high trust\n  const trustedATSPlatforms = [\n    'greenhouse.io',\n    'lever.co',\n    'workday.com',\n    'icims.com',\n    'taleo.net',\n    'jobvite.com',\n    'smartrecruiters.com',\n    'breezy.hr',\n    'recruitee.com',\n    'myworkdayjobs.com',\n    'ultipro.com'\n  ];\n  \n  // Job boards (medium trust - could be promotional)\n  const jobBoards = [\n    'linkedin.com',\n    'indeed.com',\n    'glassdoor.com',\n    'ziprecruiter.com',\n    'monster.com',\n    'careerbuilder.com'\n  ];\n  \n  // NEGATIVE PATTERNS - Auto-discard if matched\n  const negativePatterns = [\n    /unsubscribe/i,\n    /click here to view/i,\n    /view this email in your browser/i,\n    /you('re| are) receiving this (email|newsletter)/i,\n    /(weekly|daily|monthly) (digest|newsletter|roundup)/i,\n    /job (alerts?|recommendations?|matches?)/i,\n    /out of office/i,\n    /automatic reply/i,\n    /delivery status notification/i,\n    /mailer-daemon/i,\n    /tips (for|to)/i,\n    /how to (ace|prepare|succeed)/i,\n    /\\d+ (new )?jobs? (available|matching|in)/i,  // \"50 jobs available\"\n    /apply now/i,  // Usually promotional\n    /limited time/i,\n    /don't miss out/i\n  ];\n  \n  // Check negative patterns first\n  const hasNegativePattern = negativePatterns.some(pattern => \n    pattern.test(fullText)\n  );\n  \n  if (hasNegativePattern) {\n    continue; // Skip this email\n  }\n  \n  // SCORING SYSTEM\n  let totalScore = 0;\n  let maxScore = 0;\n  let matchedCompany = null;\n  let matchReasons = [];\n  \n  // FACTOR 1: Company Name Match with Job Title Disambiguation (HIGH WEIGHT: 50 points)\n  maxScore += 50;\n  let companyMatchScore = 0;\n  \n  // First pass: Find all companies that match by name or domain\n  const companyMatches = [];\n  \n  for (const company of expectedCompanies) {\n    if (!company.name) continue;\n    \n    // Check for exact company name in email\n    if (fullText.includes(company.name)) {\n      companyMatches.push({\n        company: company,\n        matchType: 'name',\n        score: 50\n      });\n    }\n    // Check for domain match\n    else {\n      for (const domain of company.domains) {\n        if (domain && senderDomain.includes(domain)) {\n          companyMatches.push({\n            company: company,\n            matchType: 'domain',\n            score: 45\n          });\n          break;\n        }\n      }\n    }\n  }\n  \n  // If we found matches, determine the best one\n  if (companyMatches.length > 0) {\n    // If multiple applications for same company, use job title as tiebreaker\n    if (companyMatches.length > 1) {\n      // Check if any job title appears in the email\n      for (const match of companyMatches) {\n        const jobTitle = match.company.jobTitle;\n        if (jobTitle && fullText.includes(jobTitle)) {\n          matchedCompany = match.company;\n          companyMatchScore = match.score;\n          matchReasons.push(`Company \"${match.company.name}\" + job title \"${jobTitle}\" found in email`);\n          break;\n        }\n      }\n      \n      // If no job title matched, take the first match (fallback to original behavior)\n      if (!matchedCompany) {\n        matchedCompany = companyMatches[0].company;\n        companyMatchScore = companyMatches[0].score;\n        matchReasons.push(`Company \"${matchedCompany.name}\" found in email (${companyMatches.length} applications, no job title match - using first)`);\n      }\n    } else {\n      // Only one match, use it\n      matchedCompany = companyMatches[0].company;\n      companyMatchScore = companyMatches[0].score;\n      const matchType = companyMatches[0].matchType === 'name' \n        ? `Company name \"${matchedCompany.name}\" found in email`\n        : `Sender domain \"${senderDomain}\" matches company \"${matchedCompany.name}\"`;\n      matchReasons.push(matchType);\n    }\n  }\n  \n  totalScore += companyMatchScore;\n  \n  // FACTOR 2: Trusted ATS Platform (MEDIUM WEIGHT: 20 points)\n  maxScore += 20;\n  let atsScore = 0;\n  const matchedATS = trustedATSPlatforms.find(ats => senderDomain.includes(ats));\n  if (matchedATS) {\n    atsScore = 20;\n    matchReasons.push(`Email from trusted ATS platform: ${matchedATS}`);\n  } else if (jobBoards.some(board => senderDomain.includes(board))) {\n    atsScore = 5;  // Lower score for job boards\n    matchReasons.push(`Email from job board`);\n  }\n  totalScore += atsScore;\n  \n  // FACTOR 3: Status Keywords with Context (VARIABLE WEIGHT: up to 30 points)\n  maxScore += 30;\n  let keywordScore = 0;\n  let detectedStatus = null;\n  let detectedStage = null;\n  let bestPatternScore = 0;\n  \n  // Enhanced patterns with context-aware matching\n  // Status: Accepted, Pending, Rejected (ApplicationDecisionStatus)\n  // Stage: Applied, PhoneScreen, Assessment, HrInterview, Offer, TechnicalInterview (ApplicationStage)\n  const statusPatterns = [\n    {\n      // Application Received\n      positiveKeywords: ['received your application', 'application submitted', 'thank you for applying', 'application complete'],\n      requiredContext: ['application', 'received'],\n      status: 'Pending',\n      stage: 'Applied',\n      score: 25\n    },\n    {\n      // Phone Screen / Initial Interview\n      positiveKeywords: ['phone screen', 'initial call', 'brief call', 'phone interview', 'introductory call'],\n      requiredContext: [],\n      negativeKeywords: ['tips for', 'how to'],\n      status: 'Pending',\n      stage: 'PhoneScreen',\n      score: 30\n    },\n    {\n      // Technical Interview\n      positiveKeywords: ['technical interview', 'coding interview', 'technical round', 'technical discussion', 'engineering interview'],\n      requiredContext: [],\n      negativeKeywords: ['tips for', 'how to'],\n      status: 'Pending',\n      stage: 'TechnicalInterview',\n      score: 30\n    },\n    {\n      // HR Interview\n      positiveKeywords: ['hr interview', 'behavioral interview', 'culture fit', 'meet with hr', 'hr round'],\n      requiredContext: [],\n      negativeKeywords: ['tips for', 'how to'],\n      status: 'Pending',\n      stage: 'HrInterview',\n      score: 30\n    },\n    {\n      // Generic Interview (when type unclear)\n      positiveKeywords: ['invite you to interview', 'schedule an interview', 'interview invitation', 'would like to meet', 'discuss your application', 'next interview'],\n      requiredContext: ['interview'],\n      negativeKeywords: ['tips for interview', 'how to interview'],\n      status: 'Pending',\n      stage: 'PhoneScreen',  // Default to PhoneScreen for generic interviews\n      score: 28\n    },\n    {\n      // Assessment\n      positiveKeywords: ['complete the assessment', 'technical challenge', 'coding test', 'take-home assignment', 'assessment link', 'technical exam', 'online assessment', 'skills assessment', 'assess your', 'passed the screening', 'next step', 'technical evaluation', 'evaluation of your skills'],\n      requiredContext: [],  // Removed strict requirement - phrases are specific enough\n      negativeKeywords: ['tips for assessment', 'how to prepare for'],\n      status: 'Pending',\n      stage: 'Assessment',\n      score: 28\n    },\n    {\n      // Offer (HIGHEST CONFIDENCE)\n      positiveKeywords: ['pleased to offer', 'job offer', 'offer letter', 'congratulations', 'offer of employment'],\n      requiredContext: ['offer'],\n      negativeKeywords: ['if we can offer', 'unable to offer'],\n      status: 'Accepted',\n      stage: 'Offer',\n      score: 30\n    },\n    {\n      // Rejection (HIGH CONFIDENCE)\n      positiveKeywords: ['not moving forward', 'decided to pursue', 'other candidates', 'not selected', 'will not be moving forward', 'you have been rejected', 'regret to inform', 'unfortunately', 'we have decided'],\n      requiredContext: [],  // Removed strict requirement - let positive keywords drive matching\n      negativeKeywords: ['if we do not', 'should you not', 'if you are not', 'tips', 'how to'],\n      status: 'Rejected',\n      stage: null,  // Don't change stage for rejection, backend will keep current stage\n      score: 28\n    }\n  ];\n  \n  for (const pattern of statusPatterns) {\n    let patternMatches = 0;\n    \n    // Check positive keywords\n    for (const keyword of pattern.positiveKeywords) {\n      if (fullText.includes(keyword)) {\n        patternMatches++;\n      }\n    }\n    \n    // Check negative keywords (disqualifies pattern)\n    if (pattern.negativeKeywords) {\n      const hasNegative = pattern.negativeKeywords.some(neg => fullText.includes(neg));\n      if (hasNegative) {\n        continue; // Skip this pattern\n      }\n    }\n    \n    // Check required context\n    const hasRequiredContext = pattern.requiredContext.every(ctx => fullText.includes(ctx));\n    \n    if (patternMatches > 0 && hasRequiredContext) {\n      const patternScore = pattern.score * (patternMatches / pattern.positiveKeywords.length);\n      \n      if (patternScore > bestPatternScore) {\n        bestPatternScore = patternScore;\n        detectedStatus = pattern.status;\n        detectedStage = pattern.stage;\n        keywordScore = patternScore;\n        const stageInfo = pattern.stage ? `stage: ${pattern.stage}` : `status: ${pattern.status}`;\n        matchReasons.push(`Detected ${stageInfo} (${patternMatches} keyword matches)`);\n      }\n    }\n  }\n  totalScore += keywordScore;\n  \n  // Calculate confidence as percentage\n  const confidence = maxScore > 0 ? (totalScore / maxScore) : 0;\n  \n  // THRESHOLD: Only proceed if confidence >= 55% AND we have a status\n  // (Balanced threshold - company match + keywords can reach 80% without ATS)\n  // Note: detectedStage can be null for rejections (backend keeps current stage)\n  if (confidence >= 0.55 && detectedStatus) {\n    // Extract company name for hint\n    let companyNameHint = matchedCompany ? matchedCompany.name : null;\n    \n    // If no matched company but ATS platform, try to extract from domain\n    if (!companyNameHint && matchedATS) {\n      const domainParts = senderDomain.split('.');\n      if (domainParts.length >= 2) {\n        companyNameHint = domainParts[0]\n          .replace(/noreply|mail|email|careers|recruiting/gi, '')\n          .trim();\n      }\n    }\n    \n    results.push({\n      json: {\n        userId: data.userId,\n        userEmail: data.userEmail,\n        emailId: data.id,\n        emailSubject: data.subject,\n        emailFrom: from,\n        emailDate: data.internalDate,\n        detectedStatus: detectedStatus,\n        detectedStage: detectedStage,\n        confidence: Math.round(confidence * 100) / 100,  // Round to 2 decimals\n        companyNameHint: companyNameHint,\n        matchedApplicationId: matchedCompany?.id || null,\n        snippet: data.snippet,\n        matchReasons: matchReasons.join('; '),\n        scoreBreakdown: {\n          companyMatch: companyMatchScore,\n          atsMatch: atsScore,\n          keywordMatch: Math.round(keywordScore * 100) / 100,\n          total: Math.round(totalScore * 100) / 100,\n          maxPossible: maxScore\n        },\n        rawEmailData: {\n          subject: data.subject,\n          from: from,\n          snippet: data.snippet\n        }\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "id": "parse-email",
      "name": "Enhanced Email Parser (Weighted Scoring)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2230, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://evident-melva-nonpunctually.ngrok-free.dev/api/gmail/webhook/email-update",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-Key",
              "value": "aB3dE5fG7hI9jK1lM2nO3pQ4rS5tU6vW7xY8zA9bC0dE="
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"userId\": {{$json.userId}},\n  \"emailData\": {\n    \"emailId\": \"{{$json.emailId}}\",\n    \"subject\": \"{{$json.emailSubject}}\",\n    \"from\": \"{{$json.emailFrom}}\",\n    \"date\": \"{{$json.emailDate}}\",\n    \"snippet\": \"{{$json.snippet}}\"\n  },\n  \"detectedStatus\": \"{{$json.detectedStatus}}\",\n  \"detectedStage\": \"{{$json.detectedStage}}\",\n  \"confidence\": {{$json.confidence}},\n  \"companyNameHint\": \"{{$json.companyNameHint}}\",\n  \"matchedApplicationId\": {{$json.matchedApplicationId}},\n  \"matchReasons\": \"{{$json.matchReasons}}\"\n}",
        "options": {}
      },
      "id": "send-to-backend",
      "name": "Send Update to Backend",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2450, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://evident-melva-nonpunctually.ngrok-free.dev/api/gmail/update-last-checked",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-Key",
              "value": "aB3dE5fG7hI9jK1lM2nO3pQ4rS5tU6vW7xY8zA9bC0dE="
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"userId\": {{$node[\"Split Into Users\"].json.userId}},\n  \"lastCheckedAt\": \"{{new Date().toISOString()}}\"\n}",
        "options": {}
      },
      "id": "update-last-checked",
      "name": "Update Last Checked Time",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2670, 200]
    },
    {
      "parameters": {},
      "id": "no-new-emails",
      "name": "No New Emails",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [1790, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://evident-melva-nonpunctually.ngrok-free.dev/api/gmail/update-last-checked",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-N8N-API-Key",
              "value": "aB3dE5fG7hI9jK1lM2nO3pQ4rS5tU6vW7xY8zA9bC0dE="
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"userId\": {{$node[\"Split Into Users\"].json.userId}},\n  \"lastCheckedAt\": \"{{new Date().toISOString()}}\"\n}",
        "options": {}
      },
      "id": "update-time-no-emails",
      "name": "Update Last Checked (No Emails)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2010, 400]
    }
  ],
  "connections": {
    "Schedule Every 5 Minutes": {
      "main": [
        [
          {
            "node": "Get Active Gmail Users",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Active Gmail Users": {
      "main": [
        [
          {
            "node": "Split Into Users",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Into Users": {
      "main": [
        [
          {
            "node": "Get User Pending Applications",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Pending Applications": {
      "main": [
        [
          {
            "node": "Check Gmail for New Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Gmail for New Emails": {
      "main": [
        [
          {
            "node": "Extract Messages & Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Messages & Context": {
      "main": [
        [
          {
            "node": "Has New Emails?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has New Emails?": {
      "main": [
        [
          {
            "node": "Fetch Full Email Details",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No New Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Full Email Details": {
      "main": [
        [
          {
            "node": "Extract Email Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Email Data": {
      "main": [
        [
          {
            "node": "Enhanced Email Parser (Weighted Scoring)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enhanced Email Parser (Weighted Scoring)": {
      "main": [
        [
          {
            "node": "Send Update to Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Update to Backend": {
      "main": [
        [
          {
            "node": "Update Last Checked Time",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Last Checked Time": {
      "main": [
        [
          {
            "node": "Split Into Users",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No New Emails": {
      "main": [
        [
          {
            "node": "Update Last Checked (No Emails)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Last Checked (No Emails)": {
      "main": [
        [
          {
            "node": "Split Into Users",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-11-02T00:00:00.000Z",
  "versionId": "3"
}
